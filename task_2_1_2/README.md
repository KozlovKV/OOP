# Первая реализация

Работать будет очень просто:
- Постоянно в сети висит менеджер, который должен установить соединение и создать поток главного обработчика задачи
- Обработчик поделит полученный массив на некоторое количество потоков и каждый отправит работать на своём порту
- Как только один из потоков найдёт непростое число, он через сокет отправит их создателю сигнал о нахождении такого числа. Если число в этом куске массива не было найдено, поток отправит другой сигнал
- По полученным от этих потоков сигналам главный обработчик решит, что следует отправить обратно клиенту

# Вторая версия
- Шлюз постоянно слушает в сети на конкретном порту
- Получая запрос на подключение от клиента, создаёт сокет и менеджер в отдельном потоке, который будет общаться с клиентом
- Менеджер принимает запросы от клиента и отправляет на них ответы до тех пор, пока соединение не будет закрыто
  - Есть мысль разделить приём и обработку запросов. Второе должны будут делать отдельные сущности в отдельных потоках

**Самый рабочий вариант повышения отказоустойчивости - создать набор из нескольких шлюзов и как-то (*хз правда как*) сообщать пользователю, на каких портах слушают шлюзы**

# Третья версия
- Шлюз, адрес и порт которого известны заранее
- При установке TCP-соединения со шлюзом, мы создаём менеджера, который будет работать с клиентом
- Получив запрос от клиента и убедившись в его корректности, менеджер посылает бродкаст запрос на порт, по которому в режиме мультикаста слушают вычислительные узлы
- Узел, получив запрос от мультикаста, отправляет в ответ свой порт (при условии, что узел доступен)
- Менеджер несколько раз пытается получить ответ от какого-либо узла и, в случае неудачи, отправляет клиенту сообщение, что узлов нет
- Успешно получив ответ от узла, менджер устанавливает с ним TCP-соединение и передаёт ему задачу
- Узел решает задачу и отправляет ответ менеджеру, который передаёт его пользователю